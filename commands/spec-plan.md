---
description: issue や指示を調査してからステアリングファイルを対話的に作成
argument-hint: 機能名 または GitHub issue URL
---

# 機能計画 (/plan)

**目的:** issue や指示からステアリングファイルを作成し、実装計画を立てる

**引数:** 機能名 または GitHub issue URL

**例:**
- `/plan ユーザープロフィールを編集` (日本語、動詞で終わる)
- `/plan ログイン機能を追加`
- `/plan https://github.com/owner/repo/issues/123`

**出力:** `.steering/[日付]-[機能名]/` ディレクトリと3つのファイル (requirements.md, design.md, tasklist.md)

---

## ステップ1: 準備とコンテキスト設定

1. **引数を解析する:**
   - **GitHub issue URL の場合:**
     - パターン: `https://github.com/{owner}/{repo}/issues/{number}`
     - `gh issue view {number} --json title,body,labels --jq '{title: .title, body: .body, labels: [.labels[].name]}'` で issue 内容を取得
     - issuecomment もすべて取得
     - タイトルから機能名を生成:
       - **日本語の場合**: そのまま保持（小文字化しない）、スペースを削除
       - **英語の場合**: 小文字化、スペースをハイフンに変換
       - スラッシュや括弧などの特殊文字を削除
       - **動詞で終わるように調整** (例: "ユーザープロフィール" → "ユーザープロフィールを編集")
       - 例:
         - "ユーザー プロフィール 編集" → "ユーザープロフィール編集"
         - "/add-feature の分割" → "add-featureを分割"
         - "Add User Profile" → "add-user-profile"
   - **機能名の場合:**
     - そのまま機能名として使用
     - **推奨**: 日本語で動詞で終わる形式 (例: "ログイン機能を追加", "パフォーマンスを改善")

2. **現在のタスクコンテキストを確立する:**
   - 機能名: `[引数または issue タイトルから生成した機能名]`
   - 日付: `[現在の日付を YYYYMMDD 形式で取得]`
   - ステアリングディレクトリパス: `.steering/[日付]-[機能名]/`
   - issue URL: `[引数が URL の場合は保持]`
   - issue 番号: `[URL から抽出、または null]`

## ステップ2: プロジェクト理解

1. `CLAUDE.md` を読み、プロジェクトの全体像を把握する
2. `docs/` ディレクトリ内の永続ドキュメントを確認し、関連する設計思想やアーキテクチャを理解する

## ステップ3: 既存パターンの調査

1. Grep ツールを使用し、機能名に関連するキーワードでソースコード (`src/`) を検索する
   ```
   Grep('[機能に関連するキーワード]', path='src/', output_mode='files_with_matches')
   ```
2. 検索結果を分析し、既存の実装パターン、命名規則、コンポーネントの利用方法を特定する

## ステップ3.5: 影響範囲の事前調査

**目的**: タスク計画時に漏れを防ぎ、正確な工数見積もりを可能にする

1. **対象ファイルの存在確認**:
   - Glob ツールで変更予定のファイルが存在するか確認
   - 例: `Glob('**/test_*.py', path='tests/')`
   - テストファイルが存在しない場合は、「テストファイル作成」を別タスクとして明示

2. **データモデル変更時の影響調査**:
   - モデル変更の場合、Grep ツールでそのモデルを使用している全箇所を検索
   - 例: `Grep('JudgmentResult', path='src/', output_mode='files_with_matches')`
   - 影響範囲（使用箇所）をリストアップ
   - 修正が必要なファイルをタスクリストに反映

3. **既存テストの影響範囲調査**:
   - モデルやシグネチャ変更の場合、既存テストへの影響を調査
   - 例: `Grep('JudgmentResult', path='tests/', output_mode='files_with_matches')`
   - テストヘルパー関数やフィクスチャの修正も考慮
   - 修正が必要なテストファイルをタスクリストに含める

4. **依存関係の確認**:
   - 新しいライブラリや外部サービスを使用する場合、依存関係をタスクに含める
   - 環境変数の追加が必要な場合も明記
   - `.env.example`の更新も忘れずに

**効果**:
- タスク計画の精度向上（想定外のタスクを削減）
- 工数見積もりの精度向上
- 実装中の「あれ、これも直す必要があった」を防ぐ

## ステップ4: 要件の明確化 (対話的確認)

1. **要件の分析:**
   - issue 本文または指示内容を分析
   - 不明点、曖昧な点、複数の解釈が可能な点をリストアップ

2. **不明点がある場合:**
   - `AskUserQuestion` ツールを使用してユーザーに確認
   - 技術的な選択肢がある場合は、候補を複数挙げて推奨度を示す
   - 例:
     ```
     質問: 「認証方式をどれにしますか?」
     選択肢:
     - JWT (推奨: ステートレスで拡張性が高い)
     - セッションベース (シンプルだがサーバー負荷が高い)
     ```

3. **要件が明確な場合:**
   - このステップをスキップして次へ

## ステップ4.5: タスクボリューム判定とファイル数選択 (対話的確認)

1. **タスクボリュームの判定:**

   以下の観点から総合的に判定:
   - issue本文の長さと複雑さ
   - 関連ファイルの数（ステップ3の検索結果から）
   - 新規機能追加 vs 既存機能修正 vs バグフィックス
   - アーキテクチャ変更の有無
   - 技術選択の複雑さ

   **判定基準:**

   - **大規模（3ファイル推奨）**: requirements + design + tasklist
     - 新機能追加
     - 複数ファイルにまたがる変更（3ファイル以上）
     - アーキテクチャ変更
     - 要件が複雑で詳細な記録が必要
     - 技術選択が複数ある

   - **中規模（2ファイル推奨）**: design + tasklist
     - 既存機能の拡張
     - 1〜2ファイルの修正
     - 要件が明確だが実装に工夫が必要
     - 設計判断が必要だが要件は明確

   - **小規模（1ファイル推奨）**: tasklist のみ
     - バグフィックス
     - 単純な機能追加
     - 単一ファイルの修正
     - 要件が極めて明確で実装が単純
     - 既存パターンの踏襲のみ

2. **判定結果をユーザーに説明:**

   ステップ1の判定結果を、根拠とともにユーザーに説明します。

   **説明内容**:
   - タスクボリュームの判定結果（大規模/中規模/小規模）
   - その判定に至った理由（具体的な根拠を箇条書きで）
   - 推奨するファイル範囲とその理由

   **例**:
   ```
   タスクボリュームを分析した結果、【大規模】と判定しました。

   判定理由:
   - 新機能追加である（ユーザープロフィール編集機能）
   - 複数ファイルにまたがる変更が予想される（3ファイル以上）
   - 認証方式など、技術選択が複数ある

   そのため、【大】requirements + design + tasklist を推奨します。
   要件、設計、タスクをすべて詳細に記録することで、
   実装中の判断ブレを防ぎ、後から振り返りやすくなります。
   ```

3. **ユーザーに選択を促す:**

   判定結果の説明後、`AskUserQuestion` ツールを使用して選択肢を提示:

   ```
   質問: 「このタスクに必要なステアリングファイルの範囲を選択してください」
   header: "ファイル範囲"

   選択肢:
   - label: "【大】requirements + design + tasklist (推奨)" (判定結果が大規模の場合)
     description: "新機能追加や複数ファイルにまたがる変更に適しています。要件、設計、タスクをすべて詳細に記録します。"

   - label: "【中】design + tasklist"
     description: "既存機能の拡張や1〜2ファイルの修正に適しています。要件は明確なので設計とタスクのみ記録します。"

   - label: "【小】tasklist のみ"
     description: "バグフィックスや単純な機能追加に適しています。タスクリストのみで進められます。"
   ```

   **注意**: 推奨度は判定結果に基づいて決定し、推奨する選択肢のlabelに「(推奨)」を追加する

4. **選択結果を保存:**

   ユーザーの選択に基づいて、以下の変数を設定:
   - `create_requirements`: true/false
   - `create_design`: true/false
   - `create_tasklist`: true (常にtrue)

## ステップ5: ステアリングファイル作成準備

1. **ステアリングディレクトリを作成する:**
   - ステップ1で確立したパスでディレクトリを作成

2. **選択されたファイルのみ作成する:**

   ステップ4.5の選択結果に基づいて、以下のファイルを作成:

   - `create_requirements == true` の場合:
     - `[ステアリングディレクトリパス]/requirements.md` (空ファイル)

   - `create_design == true` の場合:
     - `[ステアリングディレクトリパス]/design.md` (空ファイル)

   - `create_tasklist == true` の場合 (常にtrue):
     - `[ステアリングディレクトリパス]/tasklist.md` (空ファイル)

## ステップ6: 計画フェーズ (ステアリングファイル生成)

1. **`Skill('steering')` を計画モードで実行:**

   選択されたファイル範囲を指定して実行:

   - **【大】の場合**: `Skill('steering', args='mode=plan files=requirements,design,tasklist')`
   - **【中】の場合**: `Skill('steering', args='mode=plan files=design,tasklist')`
   - **【小】の場合**: `Skill('steering', args='mode=plan files=tasklist')`

   これにより、ステップ5で作成したファイルの内容が生成されます

2. **requirements.md に以下を追加:**
   - **issue との紐付け** (issue URL が存在する場合):
     ```markdown
     ## GitHub Issue
     [issue URL]

     ## issue 内容
     - タイトル: [issue.title]
     - 本文: [issue.body]
     - ラベル: [issue.labels]
     ```
   - **実装方針** (必須):
     ```markdown
     ## 実装方針
     - Kent Beck の TDD (Test-Driven Development) で実装する
     - RED → GREEN → REFACTOR のサイクルを遵守
     - テストを先に書き、最小限の実装でパスさせ、その後リファクタリング
     ```

3. **design.md にTDDサイクルの説明を追加:**
   - 実装アプローチのセクションに、TDDサイクルの具体的な手順を記載
   - 例:
     ```markdown
     ## TDDサイクル
     1. **RED**: 失敗するテストを先に書く
     2. **GREEN**: 最小限の実装でテストをパスさせる
     3. **REFACTOR**: コード品質を向上させる
     ```

4. **tasklist.md にTDD実装タスクを含める:**
   - 各実装タスクに対して、以下のサブタスクを含める:
     ```markdown
     - [ ] [機能名] を実装
       - [ ] RED: テストを先に書く
       - [ ] GREEN: 実装してテストをパスさせる
       - [ ] REFACTOR: コードを改善
     - [ ] lint/format/型チェックがすべて通る
     ```

## ステップ7: 完了確認

1. 生成されたステアリングファイルの内容をユーザーに提示

2. 以下のメッセージを表示:

   作成されたファイルのリストは選択に応じて動的に変更:

   ```
   ステアリングファイルの作成が完了しました。

   作成されたファイル:
   [選択されたファイルのみリスト表示]
   例:
   - [ステアリングディレクトリパス]/requirements.md (【大】の場合のみ)
   - [ステアリングディレクトリパス]/design.md (【大】【中】の場合のみ)
   - [ステアリングディレクトリパス]/tasklist.md (常に作成)

   内容を確認してください。

   実装を開始する場合は以下のコマンドを実行してください:
   `/implement [ステアリングディレクトリパス]`
   ```

---

## 注意事項

- 不明点がある場合は、必ず `AskUserQuestion` で確認すること
- 仮定を置かず、ユーザーの意図を正確に把握すること
- issue との紐付けは必須 (issue URL が引数の場合)
- ステアリングファイルの内容は、後続の `/implement` コマンドで使用される
- このコマンドは対話的に動作し、ユーザーの承認を得ながら進める
