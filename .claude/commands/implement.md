---
description: ステアリングファイルに基づいてTDDサイクルで実装
argument-hint: ステアリングディレクトリパス
---

# 機能実装 (/implement)

**目的:** ステアリングファイルに基づいて、Kent Beck の TDD (RED → GREEN → REFACTOR) で実装する

**引数:** ステアリングディレクトリパス (例: `/implement .steering/20260214-add-feature-split/`)

**前提条件:** ステアリングファイル (requirements.md, design.md, tasklist.md) が作成済みであること

---

## ステップ0: 実装前の品質チェック

**目的**: 既存コードのバグを事前に修正し、クリーンな状態で実装を開始

1. **型チェック実行**:
   ```bash
   .venv/bin/mypy src/
   ```
   - 既存のバグや型エラーを発見
   - 実装開始前に修正することで、後で混乱を避ける
   - 実例: `social_proof_fetcher.py`の構文エラー発見（except句のバグ）

2. **リントチェック実行**:
   ```bash
   .venv/bin/ruff check src/
   ```
   - コードスタイルの問題を事前に修正
   - 既存の警告やエラーを解消

3. **エラーが見つかった場合**:
   - 実装開始前に既存バグを修正
   - 修正後、再度チェックを実行して確認
   - クリーンな状態になってから実装開始

**効果**:
- 既存バグの早期発見・修正
- 実装中のエラーを最小化
- デバッグ時間の削減

**注意**: このステップで見つかったエラーは、今回の実装タスクとは別にコミットすることを推奨

## ステップ1: ステアリングファイルの読み込み

1. **引数の検証:**
   - ステアリングディレクトリパスが存在するか確認
   - 必要なファイルが存在するか確認:
     - `[ステアリングディレクトリパス]/requirements.md`
     - `[ステアリングディレクトリパス]/design.md`
     - `[ステアリングディレクトリパス]/tasklist.md`

2. **ステアリングファイルを読み込む:**
   - 上記3ファイルを全て読み込み、実装内容を理解する
   - issue URL が記載されている場合は、issue と紐づける

## ステップ2: TDD実装ループ (tasklist.mdの完全消化)

**このステップは、`tasklist.md`の全タスクが `[x]` になるまで自動で繰り返されるループ処理です。**

**ループ開始:**

1. **タスクリストの読み込み:**
   - `[ステアリングディレクトリパス]/tasklist.md` ファイルを読み込む

2. **進捗の確認:**
   - ファイル内に未完了タスク (`[ ]`) が存在するか確認する
   - **もし未完了タスクが存在しない場合:** この実装ループは完了とみなし、ただちに**ステップ3**へ進む
   - **もし未完了タスクが存在する場合:** 次の処理（3. TDDサイクルの実行）に進む

3. **TDDサイクルの実行:**

   `tasklist.md` の**先頭にある未完了タスク**を1つ特定し、以下のTDDサイクルで実装する:

   **🔴 RED (失敗するテストを先に書く):**
   - タスクに対応するテストケースを `tests/` ディレクトリに追加
   - テストの実装:
     - 既存のテストパターンを参考にする
     - `pytest` の規約に従う
     - アサーションを明確に記述
   - テストを実行して失敗を確認:
     ```bash
     .venv/bin/pytest [追加したテストファイル] -v
     ```
   - **期待結果:** テストが失敗すること (RED状態)

   **🟢 GREEN (最小限の実装でテストをパスさせる):**
   - タスクを完了させるために必要な最小限の実装を行う
   - `Skill('steering')` を実装モードで使用
   - `Skill('development-guidelines')` のコーディング規約を常に遵守
   - 実装後、テストを実行してパスを確認:
     ```bash
     .venv/bin/pytest tests/ -v
     ```
   - **期待結果:** テストが全てパスすること (GREEN状態)

   **🔵 REFACTOR (コードを改善):**
   - コード品質を向上させる:
     - 重複コードの排除 (DRY原則)
     - 可読性の向上
     - パフォーマンスの最適化
   - リファクタリング後、テストを再実行して全てパスすることを確認:
     ```bash
     .venv/bin/pytest tests/ -v
     ```
   - **期待結果:** リファクタリング後もテストが全てパスすること

4. **タスクリストの更新:**
   - 実行したタスクが完了したら、`Edit` ツールを使用して `tasklist.md` を更新し、該当タスクを `[ ]` から `[x]` に変更する

5. **ループ継続:**
   - **ステップ2の先頭 (1. タスクリストの読み込み) に戻り、処理を繰り返す**

---

### ※ 実装ループ内の例外処理ルール ※

実装ループの実行中に以下の状況が発生した場合は、このルールに従って自律的に対処し、ループを継続すること。

- **ルールA: タスクが大きすぎる場合**
  - **対処法:** 現在のタスクをより小さな複数のサブタスクに分割する。`Edit` ツールを使い、元のタスクを削除し、その場所に新しいサブタスク（`[ ]`付き）を挿入する。その後、ループを継続する。

- **ルールB: 技術的理由でタスクが不要になった場合**
  - **条件:** 実装方針の変更、アーキテクチャの変更、依存関係の変更など、明確な技術的理由がある場合にのみ適用。
  - **対処法:** `Edit` ツールを使い、該当タスクを `[x] ~~タスク名~~ (理由: [具体的な技術的理由を簡潔に記述])` の形式で更新する。その後、ループを継続する。

- **❌ 絶対禁止の行為:**
  - 未完了タスクを「後でやる」「別タスクにする」などの理由で意図的にスキップすること
  - 理由なく未完了タスクを放置してループを終了させること
  - TDDサイクルをスキップすること (必ず RED → GREEN → REFACTOR の順で実行)

---

## ステップ3: 実装検証 (サブエージェント起動)

1. `tasklist.md` の全タスクが完了したことを最終確認する

2. `Task` ツールを使用し、`implementation-validator` サブエージェントを起動して品質を検証する:
   - `subagent_type`: "implementation-validator"
   - `description`: "Implementation quality validation"
   - `prompt`: "今回実装した機能に関する全ての変更点の品質を検証してください。対象ファイルは `[実装したファイルのパスリスト]` です。コーディング規約、エラーハンドリング、テスト可能性、既存パターンとの整合性を重点的に確認してください。"

## ステップ4: 自動テストと品質チェック

### 4-1. テスト実行

```bash
.venv/bin/pytest tests/ -v
```

- **期待結果**: 全テストがパス
- **エラーの場合**: テストを修正してから次に進む

### 4-2. Ruff違反の修正（重要）

**フロー**:

1. **エラー確認**:
   ```bash
   .venv/bin/ruff check src/
   ```

2. **エラーがある場合、以下の手順で修正**:

   **a) 自動修正を実行**:
   ```bash
   .venv/bin/ruff check src/ --fix
   ```
   - 自動修正可能なエラー（import順序、不要な空白等）が修正される
   - 修正内容を確認する

   **b) 残りのエラーを確認**:
   ```bash
   .venv/bin/ruff check src/
   ```
   - 手動修正が必要なエラーがリスト表示される

   **c) エラーの優先順位を判断**:
   - **高優先度**: セキュリティ（S）、async誤用（ASYNC）、複雑度（C90）
   - **中優先度**: print文（T20）、命名規則（N）、pylint（PL）
   - **低優先度**: 簡素化（SIM）、不要コード（PIE）、return改善（RET）

   **d) 手動修正を実行**:
   - エラーメッセージを確認し、該当箇所を修正
   - 例:
     - `S` (セキュリティ): ハードコードされた認証情報を環境変数に移行
     - `C90` (複雑度): 関数を分割してシンプルにする
     - `T20` (print): print文をstructlog.loggerに置き換え
     - `N` (命名規則): 関数名・変数名をPEP8準拠に修正

   **e) 再確認**:
   ```bash
   .venv/bin/ruff check src/
   ```
   - **期待結果**: `All checks passed!` が表示される

3. **コードフォーマット**:
   ```bash
   .venv/bin/ruff format src/
   ```
   - コードスタイルを統一
   - ダブルクォート、インデント、行の折り返し等を自動調整

4. **🔄 修正後のテスト再実行（重要）**:
   ```bash
   .venv/bin/pytest tests/ -v
   ```
   - **理由**: ruff違反の修正でコードが変更されたため、テストが壊れていないか確認
   - **期待結果**: 全テストがパス
   - **エラーの場合**: 修正したコードを見直し、テストを修正してから次に進む

### 4-3. 型チェック

```bash
.venv/bin/mypy src/
```

- **期待結果**: `Success: no issues found`
- **エラーの場合**: 型ヒントを追加・修正してから次に進む

### 4-4. 最終確認

全てのチェックがパスしたことを確認:
- ✅ pytest: 全テストパス
- ✅ ruff check: `All checks passed!`
- ✅ ruff format: フォーマット適用済み
- ✅ mypy: `Success: no issues found`

## ステップ5: 振り返りとドキュメント更新

1. **`Skill('steering')` を振り返りモードで実行:**
   - `tasklist.md` に申し送り事項を記載:
     - 実装完了日
     - 計画と実績の差分
     - 学んだこと
     - 次回への改善提案

2. **永続ドキュメントの更新判断:**
   - 今回の変更がプロジェクトの基本設計やアーキテクチャに影響を与えるか判断する

3. **必要に応じてドキュメント更新:**
   - 影響がある場合、`docs/` 内の関連する永続ドキュメントを `Edit` ツールで更新する

## 完了条件

このコマンドは、以下の全ての条件を満たした時点で完了となる:
- ステップ2: `tasklist.md` の全てのタスクが完了状態（`[x]` または正当な理由でスキップ）になっている
- ステップ3: `implementation-validator` サブエージェントの検証をパスする
- ステップ4: `pytest`, `ruff`, `mypy` の全てのコマンドがエラーなく成功する
- ステップ5: `tasklist.md` に申し送り事項が記載されている

## 完了メッセージ

実装が完了したら、ユーザーに以下の形式で報告する:

```
✅ 実装が完了しました

### 品質チェック
- ✅ pytest: [結果]
- ✅ ruff check: All checks passed!
- ✅ mypy: Success: no issues found

### 次のステップ

コミット、push、issueクローズを実行:

/commit-push-close

（issue番号とステアリングファイルは会話から自動検出されます）
```

**重要**:
- 基本的に `/commit-push-close` のみを提示（引数なし）
- 会話からissue番号とステアリングファイルが自動検出されることを説明
- シンプルで分かりやすいメッセージにする

---

## TDDサイクルの重要性

Kent Beck の TDD は、以下の利点があります:
- **RED**: テストを先に書くことで、要件を明確化
- **GREEN**: 最小限の実装で素早くフィードバック
- **REFACTOR**: テストがある状態で安全にコード改善

このサイクルを必ず守ることで、高品質なコードを効率的に実装できます。

---

## コスト・リスク管理のガイドライン

### 外部API呼び出しを伴う動作確認

**原則**: ユーザーに確認を取る

以下の場合は、実行前に `AskUserQuestion` ツールで確認すること:
- LLM API（Bedrock）の呼び出し
- 有料APIの呼び出し
- メール送信（SES）
- 外部サービスへの書き込み操作

**確認例**:
```
質問: 「ローカル環境でLLM判定を実行しますか？」
header: "動作確認"

選択肢:
- label: "スキップする（推奨）"
  description: "テストは全てパス済み。コストを避けるため、実行をスキップします。"

- label: "実行する"
  description: "実際にLLM APIを呼び出して動作確認します。コスト: 約14円/30記事"
```

**理由**:
- 不要なコストを削減
- ユーザーの意思決定を尊重
- リスクの可視化

### 実装中の中間チェック

**フェーズごとの軽量チェック**:

各TDDサイクル（RED/GREEN/REFACTOR）完了時に、以下の軽量なチェックを実行すると効果的:

```bash
# 関連するテストのみ実行（高速）
.venv/bin/pytest tests/unit/services/test_buzz_scorer.py -v

# 型チェック（変更ファイルのみ）
.venv/bin/mypy src/services/buzz_scorer.py
```

**効果**:
- 早期にエラーを発見
- デバッグコストを削減
- 実装の方向性を随時確認
