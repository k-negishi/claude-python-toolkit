---
description: ステアリングファイルに基づいてTDDサイクルで実装
argument-hint: ステアリングディレクトリパス
---

# 機能実装 (/implement)

**目的:** ステアリングファイルに基づいて、Kent Beck の TDD (RED → GREEN → REFACTOR) で実装する

**引数:** ステアリングディレクトリパス (例: `/implement .steering/20260214-add-feature-split/`)

**前提条件:** ステアリングファイル (requirements.md, design.md, tasklist.md) が作成済みであること

---

## ステップ1: ステアリングファイルの読み込み

1. **引数の検証:**
   - ステアリングディレクトリパスが存在するか確認
   - 必要なファイルが存在するか確認:
     - `[ステアリングディレクトリパス]/requirements.md`
     - `[ステアリングディレクトリパス]/design.md`
     - `[ステアリングディレクトリパス]/tasklist.md`

2. **ステアリングファイルを読み込む:**
   - 上記3ファイルを全て読み込み、実装内容を理解する
   - issue URL が記載されている場合は、issue と紐づける

## ステップ2: TDD実装ループ (tasklist.mdの完全消化)

**このステップは、`tasklist.md`の全タスクが `[x]` になるまで自動で繰り返されるループ処理です。**

**ループ開始:**

1. **タスクリストの読み込み:**
   - `[ステアリングディレクトリパス]/tasklist.md` ファイルを読み込む

2. **進捗の確認:**
   - ファイル内に未完了タスク (`[ ]`) が存在するか確認する
   - **もし未完了タスクが存在しない場合:** この実装ループは完了とみなし、ただちに**ステップ3**へ進む
   - **もし未完了タスクが存在する場合:** 次の処理（3. TDDサイクルの実行）に進む

3. **TDDサイクルの実行:**

   `tasklist.md` の**先頭にある未完了タスク**を1つ特定し、以下のTDDサイクルで実装する:

   **🔴 RED (失敗するテストを先に書く):**
   - タスクに対応するテストケースを `tests/` ディレクトリに追加
   - テストの実装:
     - 既存のテストパターンを参考にする
     - `pytest` の規約に従う
     - アサーションを明確に記述
   - テストを実行して失敗を確認:
     ```bash
     .venv/bin/pytest [追加したテストファイル] -v
     ```
   - **期待結果:** テストが失敗すること (RED状態)

   **🟢 GREEN (最小限の実装でテストをパスさせる):**
   - タスクを完了させるために必要な最小限の実装を行う
   - `Skill('steering')` を実装モードで使用
   - `Skill('development-guidelines')` のコーディング規約を常に遵守
   - 実装後、テストを実行してパスを確認:
     ```bash
     .venv/bin/pytest tests/ -v
     ```
   - **期待結果:** テストが全てパスすること (GREEN状態)

   **🔵 REFACTOR (コードを改善):**
   - コード品質を向上させる:
     - 重複コードの排除 (DRY原則)
     - 可読性の向上
     - パフォーマンスの最適化
   - リファクタリング後、テストを再実行して全てパスすることを確認:
     ```bash
     .venv/bin/pytest tests/ -v
     ```
   - **期待結果:** リファクタリング後もテストが全てパスすること

4. **タスクリストの更新:**
   - 実行したタスクが完了したら、`Edit` ツールを使用して `tasklist.md` を更新し、該当タスクを `[ ]` から `[x]` に変更する

5. **ループ継続:**
   - **ステップ2の先頭 (1. タスクリストの読み込み) に戻り、処理を繰り返す**

---

### ※ 実装ループ内の例外処理ルール ※

実装ループの実行中に以下の状況が発生した場合は、このルールに従って自律的に対処し、ループを継続すること。

- **ルールA: タスクが大きすぎる場合**
  - **対処法:** 現在のタスクをより小さな複数のサブタスクに分割する。`Edit` ツールを使い、元のタスクを削除し、その場所に新しいサブタスク（`[ ]`付き）を挿入する。その後、ループを継続する。

- **ルールB: 技術的理由でタスクが不要になった場合**
  - **条件:** 実装方針の変更、アーキテクチャの変更、依存関係の変更など、明確な技術的理由がある場合にのみ適用。
  - **対処法:** `Edit` ツールを使い、該当タスクを `[x] ~~タスク名~~ (理由: [具体的な技術的理由を簡潔に記述])` の形式で更新する。その後、ループを継続する。

- **❌ 絶対禁止の行為:**
  - 未完了タスクを「後でやる」「別タスクにする」などの理由で意図的にスキップすること
  - 理由なく未完了タスクを放置してループを終了させること
  - TDDサイクルをスキップすること (必ず RED → GREEN → REFACTOR の順で実行)

---

## ステップ3: 実装検証 (サブエージェント起動)

1. `tasklist.md` の全タスクが完了したことを最終確認する

2. `Task` ツールを使用し、`implementation-validator` サブエージェントを起動して品質を検証する:
   - `subagent_type`: "implementation-validator"
   - `description`: "Implementation quality validation"
   - `prompt`: "今回実装した機能に関する全ての変更点の品質を検証してください。対象ファイルは `[実装したファイルのパスリスト]` です。コーディング規約、エラーハンドリング、テスト可能性、既存パターンとの整合性を重点的に確認してください。"

## ステップ4: 自動テストの実行

1. 以下のコマンドを順番に実行し、全てのチェックがパスすることを確認する:
   ```bash
   # 1. テスト実行
   .venv/bin/pytest tests/ -v

   # 2. リントチェック
   .venv/bin/ruff check src/

   # 3. コードフォーマット
   .venv/bin/ruff format src/

   # 4. 型チェック
   .venv/bin/mypy src/
   ```

2. いずれかのコマンドでエラーが発生した場合は、問題を分析し、修正コードを生成・適用してから、再度このステップを実行する

## ステップ5: 振り返りとドキュメント更新

1. **`Skill('steering')` を振り返りモードで実行:**
   - `tasklist.md` に申し送り事項を記載:
     - 実装完了日
     - 計画と実績の差分
     - 学んだこと
     - 次回への改善提案

2. **永続ドキュメントの更新判断:**
   - 今回の変更がプロジェクトの基本設計やアーキテクチャに影響を与えるか判断する

3. **必要に応じてドキュメント更新:**
   - 影響がある場合、`docs/` 内の関連する永続ドキュメントを `Edit` ツールで更新する

## 完了条件

このコマンドは、以下の全ての条件を満たした時点で完了となる:
- ステップ2: `tasklist.md` の全てのタスクが完了状態（`[x]` または正当な理由でスキップ）になっている
- ステップ3: `implementation-validator` サブエージェントの検証をパスする
- ステップ4: `pytest`, `ruff`, `mypy` の全てのコマンドがエラーなく成功する
- ステップ5: `tasklist.md` に申し送り事項が記載されている

---

## TDDサイクルの重要性

Kent Beck の TDD は、以下の利点があります:
- **RED**: テストを先に書くことで、要件を明確化
- **GREEN**: 最小限の実装で素早くフィードバック
- **REFACTOR**: テストがある状態で安全にコード改善

このサイクルを必ず守ることで、高品質なコードを効率的に実装できます。
